module GitHub
  module Replicator
    # Dump replicants in a streaming fashion.
    #
    # The Dumper takes an ActiveRecord object and generates one or more replicant
    # objects. A replicant has the form: [type, id, attributes] and describes
    # exactly one record in the database. The type and id identify the record's
    # model class name string and primary key id, respectively. The attributes
    # is a Hash of primitive typed objects generated by a call to
    # ActiveRecord::Base#attributes.
    #
    # Dumping to an array:
    #
    #     >> dumper = Replicator::Dumper.new
    #     >> dumper.dump(User / :defunkt / :github)
    #     >> pp dumper.to_a
    #
    # Dumping to stdout in marshal format:
    #
    #     >> writer = lambda { |*a| Marshal.dump(a, $stdout) }
    #     >> dumper = Replicator::Dumper.new(&writer)
    #     >> dumper.dump(User / :defunkt / :github)
    class Dumper
      # Create a new Dumper.
      #
      # io     - IO object to write marshalled replicant objects to. When
      #          not given, objects are written to an array available at #to_a.
      # write  - Block called when an object needs to be written. Use this for
      #          complete control over how objects are serialized.
      def initialize(io=nil, &write)
        @filters = []
        @memo = Hash.new { |hash,k| hash[k] = {} }

        marshal_to io if io
        filter write  if write
      end

      # Register a dump filter. Guaranteed to be called exactly once per
      # distinct object with the type, id, attributes, object structure. Filters
      # may modify the attributes hash to modify the view of successive filters.
      # Filters are executed in the reverse order of which they were registered.
      # This means filters registered later modify the view of filters
      # registered earlier.
      #
      # Dump filters are used to implement all output generating as well as
      # logging status output.
      #
      # p - An optional Proc object. Must respond to call.
      # block - An optional block.
      #
      # Returns nothing.
      def filter(p=nil, &block)
        @filters.unshift p if p
        @filters.unshift block if block
      end

      # Sugar for creating a filter with an object instance. Instances of the
      # class must respond to call(type, id, attrs, object).
      #
      # klass - The class to create. Must respond to new.
      # args  - Arguments to pass to klass#new in addition to self.
      #
      # Returns the object created.
      def use(klass, *args, &block)
        instance = klass.new(self, *args, &block)
        filter instance
        instance
      end

      # Register a filter to write marshalled data to the given IO object.
      def marshal_to(io)
        filter do |type, id, attrs, obj|
          Marshal.dump([type, id, attrs], io)
        end
      end

      # Dump one or more objects to the internal array or provided dump
      # stream. This method guarantees that the same object will not be dumped
      # more than once.
      #
      # objects - ActiveRecord object instances.
      #
      # Returns nothing.
      def dump(*objects)
        objects = objects[0] if objects.size == 1 && objects[0].respond_to?(:to_ary)
        objects.each do |object|
          next if object.nil? || dumped?(object)
          if object.respond_to?(:dump_replicant)
            object.dump_replicant(self)
          else
            warn "error: #{object.class} does not define #dump_replicant"
          end
        end
      end

      # Check if object has been dumped yet.
      def dumped?(object)
        if object.respond_to?(:replicant_id)
          type, id = object.replicant_id
        elsif object.is_a?(Array)
          type, id = object
        else
          return false
        end
        @memo[type][id]
      end

      # Call the write method given in the initializer or write to the internal
      # objects array when no write method was given.
      #
      # type       - The model class name as a String.
      # id         - The record's id. Usually an integer.
      # attributes - All model attributes.
      # object     - The object this dump is generated for.
      #
      # Returns nothing.
      def write(type, id, attributes, object)
        return if dumped?([type, id])
        @memo[type][id] = true

        @filters.each { |meth| meth.call(type, id, attributes, object) }
      end

      # Retrieve dumped object counts for all classes.
      #
      # Returns a Hash of { class_name => count } where count is the number of
      # objects dumped with a class of class_name.
      def stats
        stats = {}
        @memo.each { |class_name, items| stats[class_name] = items.size }
        stats
      end

      # Grab dumped objects array. Always empty when a custom write function was
      # provided when initialized.
      def to_a
        @objects
      end
    end
  end
end
